# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/00_tests/utils/tst.utils.ipynb (unless otherwise specified).

__all__ = ['test_make_reproducible', 'test_set_logger', 'test_set_tf_loglevel', 'test_get_hierarchy',
           'test_replace_attr_and_store', 'test_replace_attr_and_store_no_rec']

# Cell
import pytest
import os
import joblib
from IPython.display import display
import pandas as pd
import numpy as np
import logging
import shutil

from block_types.utils.utils import *
import block_types.config.bt_defaults as dflt

# Cell
#@pytest.fixture (name='example_people_data')
#def example_people_data_fixture():
#    return example_people_data()

# Comes from utils.ipynb, cell
#@pytest.mark.reference_fails
def test_make_reproducible ():
    make_reproducible ()
    x = np.random.rand(10)
    make_reproducible ()
    x2 = np.random.rand(10)
    assert (x==x2).all()

# Comes from utils.ipynb, cell
#@pytest.mark.reference_fails
def test_set_logger ():
    logger = set_logger ('test', path_results='test_logger')

    assert os.listdir ('test_logger')==['logs.txt']

    assert logger.level==logging.DEBUG

    logger = set_logger ('test', path_results='test_logger', verbose=1)
    assert logger.level==logging.INFO

    set_verbosity (logger=logger, verbose=0)
    assert logger.level==logging.WARNING

    for hdlr in logger.handlers[:]:  # remove all old handlers
        assert hdlr.level==logging.WARNING

    shutil.rmtree ('test_logger')

# Comes from utils.ipynb, cell
#@pytest.mark.reference_fails
def test_set_tf_loglevel ():
    set_tf_loglevel (logging.DEBUG)
    assert logging.getLogger('tensorflow').getEffectiveLevel()==logging.DEBUG

# Comes from utils.ipynb, cell
#@pytest.mark.reference_fails
def test_get_hierarchy ():
    def f (**kwargs):
        return B(**kwargs)

    class A ():
        def __init__ (self, x=3, **kwargs):
            self.hierarchy_level = get_hierarchy_level(base_class=A)

    class B(A):
        def __init__ (self, y=10, **kwargs):
            super().__init__ (**kwargs)
            self.ab = A (**kwargs)

    class C(B):
        def __init__ (self, z=100, **kwargs):
            super().__init__ (**kwargs)
            self.a = A(**kwargs)
            self.b = f(**kwargs)
    class D(C):
        def __init__ (self, h=100, **kwargs):
            super().__init__ (**kwargs)
            self.c = C(**kwargs)
            self.b = f(**kwargs)
    a = A()
    b = B()
    c = C()
    d = D()

    assert (a.hierarchy_level==0 and b.hierarchy_level==0 and c.hierarchy_level==0
            and c.a.hierarchy_level==1 and c.b.hierarchy_level==1 and c.ab.hierarchy_level==1
            and c.b.ab.hierarchy_level==2
            and d.hierarchy_level == 0 and d.a.hierarchy_level == 1 and d.b.hierarchy_level == 1
            and d.ab.hierarchy_level == 1
            and d.b.hierarchy_level==1 and d.b.ab.hierarchy_level==2 and d.c.b.ab.hierarchy_level==3)

# Comes from utils.ipynb, cell
#@pytest.mark.reference_fails
def test_replace_attr_and_store ():
    def f (**kwargs):
        return B(**kwargs)

    class A ():
        def __init__ (self, x=3, **kwargs):
            replace_attr_and_store (base_class=A)

    class B(A):
        def __init__ (self, y=10, **kwargs):
            super().__init__ (**kwargs)
            self.ab = A (**kwargs)

    class C(A):
        def __init__ (self, z=100, **kwargs):
            super().__init__ (**kwargs)
            self.a = A(**kwargs)
            self.b = f(**kwargs)
    a = A()
    b = B()
    c = C()

    assert a.x==3 and b.y==10 and b.x==3 and c.z==100 and c.x==3 and c.a.x==3 and c.b.y==10 and c.b.x==3

    with pytest.raises (AttributeError):
        print (c.y)

    with pytest.raises (AttributeError):
        print (c.a.y)

    with pytest.raises (AttributeError):
        print (c.a.z)

    with pytest.raises (AttributeError):
        print (b.z)

    with pytest.raises (AttributeError):
        print (b.ab.y)

    # **************************************************
    # test changing the argument
    # **************************************************
    def f2 (y=10, **kwargs):
        y = 2*y
        return B2 (y=y, **kwargs)

    class A2 ():
        def __init__ (self, x='hello', **kwargs):
            x=f'{x} world'
            replace_attr_and_store (base_class=A2)

    class B2 (A2):
        def __init__ (self, y=10, **kwargs):
            super().__init__ (**kwargs)
            self.ab = A2 (**kwargs)

    class C2 (A2):
        def __init__ (self, z=100, **kwargs):
            super().__init__ (**kwargs)
            self.a = A2(**kwargs)
            self.b = f2 (**kwargs)
    a = A2()
    b = B2()
    c = C2()
    assert (a.x, b.x, b.ab.x) == ('hello world', 'hello world', 'hello world')
    assert c.b.y == 20

    a = A2 ('hey')
    b = B2 ()
    assert (a.x, b.x, b.ab.x) == ('hey world', 'hello world', 'hello world')

    c = C2 (y=3, x='Hi')
    assert (c.b.y, c.b.x) == (6, 'Hi world')

# Comes from utils.ipynb, cell
#@pytest.mark.reference_fails
def test_replace_attr_and_store_no_rec ():
    # test without recursiveness
    from sklearn.utils import Bunch

    def f (x=3, y=4, z=5, **kwargs):
        estimator = Bunch ()
        replace_attr_and_store (recursive=False,
                                self=estimator, include_first=True)
        return estimator

    estimator = f (y=40, z=50)

    stored_args = estimator.pop('__stored_args__')
    assert estimator=={'x': 3, 'y': 40, 'z': 50}
    assert stored_args == estimator

    # test without kwargs
    def g (x=3, y=4, z=5):
        estimator = Bunch ()
        replace_attr_and_store (recursive=False,
                                self=estimator, include_first=True)
        return estimator

    estimator = g (y=40, z=50)

    stored_args = estimator.pop('__stored_args__')
    assert estimator=={'x': 3, 'y': 40, 'z': 50}
    assert stored_args == estimator

    # test without kwargs and with replace_generic_attr=False
    def h (x=3, y=4, z=5):
        estimator = Bunch ()
        replace_attr_and_store (recursive=False,
                                self=estimator, include_first=True, replace_generic_attr=False)
        return estimator

    estimator = h (y=40, z=50)

    stored_args = estimator.pop('__stored_args__')
    assert estimator=={'x': 3, 'y': 40, 'z': 50}
    assert stored_args == estimator