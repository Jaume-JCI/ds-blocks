---

title: Data Conversion


keywords: fastai
sidebar: home_sidebar

summary: "Convert data format to fit the needs of a given component. Contrary to Transforms, the DataConverter classes only change the format of the data, not the data iself."
description: "Convert data format to fit the needs of a given component. Contrary to Transforms, the DataConverter classes only change the format of the data, not the data iself."
nb_path: "nbs/core.data_conversion.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nbs/core.data_conversion.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="DataConverter" class="doc_header"><code>class</code> <code>DataConverter</code><a href="https://github.com/Jaume-JCI/block_types/blob/main/block_types/core/data_conversion.py#L14" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>DataConverter</code>(<strong><code>logger</code></strong>=<em><code>None</code></em>, <strong><code>verbose</code></strong>:<code>int</code>=<em><code>1</code></em>, <strong>**<code>kwargs</code></strong>)</p>
</blockquote>

<pre><code>Convert input and output data format.

This class allows to convert the format of the data before fitting
and before transforming, and revert the changes back after performing
these operations. This allows to decouple the implementation of a
particular component from the remaining components in the pipeline,
making it more reusable across different pipelines.</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="DataConverter.__init__" class="doc_header"><code>DataConverter.__init__</code><a href="__main__.py#L20" class="source_link" style="float:right">[source]</a></h3><blockquote><p><code>DataConverter.__init__</code>(<strong><code>logger</code></strong>=<em><code>None</code></em>, <strong><code>verbose</code></strong>:<code>int</code>=<em><code>1</code></em>, <strong>**<code>kwargs</code></strong>)</p>
</blockquote>

<pre><code>Initialize common attributes and fields, in particular the logger.

Parameters
----------
logger : logging.Logger or None, optional
    Logger used to write messages
verbose : int, optional
    Verbosity, 0: warning or critical, 1: info, 2: debug.</code></pre>

</div>

</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="DataConverter.convert_before_fitting" class="doc_header"><code>DataConverter.convert_before_fitting</code><a href="__main__.py#L37" class="source_link" style="float:right">[source]</a></h3><blockquote><p><code>DataConverter.convert_before_fitting</code>(<strong><code>X</code></strong>, <strong><code>y</code></strong>=<em><code>None</code></em>)</p>
</blockquote>

<pre><code>Convert incoming data before running fit method.

Parameters
----------
X : data (N observations x D dimensions)
    data used for fitting model parameters
y : labels (N observations), optional
    One dimensional array with N groundtruth labels.

Returns
-------
X : data (N observations x D dimensions)
    data with transformed format but same content
y : labels (N observations)
    labels with transformed format but same content</code></pre>

</div>

</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="DataConverter.convert_after_fitting" class="doc_header"><code>DataConverter.convert_after_fitting</code><a href="__main__.py#L58" class="source_link" style="float:right">[source]</a></h3><blockquote><p><code>DataConverter.convert_after_fitting</code>(<strong><code>X</code></strong>)</p>
</blockquote>

<pre><code>Convert data after running fit method.

Calling this method is only required when convert_before_fitting 
changes X "in place", instead of changing a copy of X. This might 
be more efficient sometimes, and we have convert_after_fitting to 
revert the previous change.

Parameters
----------
X : data (N observations x D dimensions)
    data used for fitting model parameters

Returns
-------
X : data (N observations x D dimensions)
    data with transformed format but same content</code></pre>

</div>

</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="DataConverter.convert_before_transforming" class="doc_header"><code>DataConverter.convert_before_transforming</code><a href="__main__.py#L80" class="source_link" style="float:right">[source]</a></h3><blockquote><p><code>DataConverter.convert_before_transforming</code>(<strong><code>X</code></strong>, <strong>**<code>kwargs</code></strong>)</p>
</blockquote>

<pre><code>Convert data before running transform method.

Parameters
----------
X : data (N observations x D dimensions)
    data used to be transformed

Returns
-------
X : data (N observations x D dimensions)
    data with transformed format but same content</code></pre>

</div>

</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="DataConverter.convert_after_transforming" class="doc_header"><code>DataConverter.convert_after_transforming</code><a href="__main__.py#L97" class="source_link" style="float:right">[source]</a></h3><blockquote><p><code>DataConverter.convert_after_transforming</code>(<strong><code>result</code></strong>, <strong>**<code>kwargs</code></strong>)</p>
</blockquote>

<pre><code>Convert result obtained after by transform method.

Parameters
----------
result : data (N' observations x D' dimensions)
        result obtained by transformed method

Returns
-------
result : data (N' observations x D' dimensions)
    result with transformed format but same content</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="PandasConverter" class="doc_header"><code>class</code> <code>PandasConverter</code><a href="https://github.com/Jaume-JCI/block_types/blob/main/block_types/core/data_conversion.py#L119" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>PandasConverter</code>(<strong><code>transform_uses_labels</code></strong>=<em><code>False</code></em>, <strong><code>transformed_index</code></strong>=<em><code>None</code></em>, <strong><code>transformed_columns</code></strong>=<em><code>None</code></em>, <strong><code>separate_labels</code></strong>=<em><code>True</code></em>, <strong>**<code>kwargs</code></strong>) :: <a href="/core.data_conversion.html#DataConverter"><code>DataConverter</code></a></p>
</blockquote>

<pre><code>Convert DataFrame to numpy array and back, if needed.

By default, this class assumes the following:

    - When calling the fit method, the data is received
      as a DataFrame. This DataFrame contains not only the
      data to be used for fitting our model, but also the
      ground-truth labels. The `PandasConverter` takes only
      the data needed for fitting the model, and puts it
      into a matrix `X`, and then takes the labels and puts
      them into a separate vector `y`. While all this is done
      by default, the `PandasConverter` also allows other
      possibilities: receiving the data and the labels separately
      in `X` and `y`, in which case no action is needed, or avoiding
      to separate the data and the labels (if the flag `separate_labels` is False),
      in which case the matrix `X` will contain both data and labels.
      It also allows to receive numpy arrays instead of DataFrames,
      in which case the data format is preserved.

    - When calling the `transform` method, the `PandasConverter`
      removes by default the labels from the incoming DataFrame,
      and then puts them back after performing the transformation.
      This behaviour can change if we set `transform_needs_labels=True`.
      In this case, the labels are kept in the matrix `X` so that
      they can be used during the transformation. This is done in
      particular by one type of component called `SamplingComponent`,
      defined in `core.component_types`. This is useful for
      components that do some sort of under-sampling or over-sampling,
      changing the number of observations. When this occurs, the
      labels need to be adjusted accordingly, so that the `transform`
      method modifies both the data and the labels, both of whom are
      contained in the output matrix `X`.

    The  default `DataConverter` used in the current implementation is the
    `PandasConverter`.

    #### Note on generic use of metadata (to be implemented)

    In general, our DataFrames behave like a single-table in-memory DataBases
    from which we can take the necessary data and metadata to perform any
    operation needed in our pipeline. Although currently we only consider
    groundtruth labels as metadata, in the future we plan to allow any other
    metadata indicated by configuration. This includes the `chiller_id`, which
    might be needed by some of the components, to differentiate between the data of
    different chillers, for data-sets with more than one chiller. Currently
    our dataset contains a single chiller, and this type of metadata is not needed.
    Regardless of the metadata being used, the `PandasConverter` takes only the data
    needed for fitting the model, puts it into a matrix `X`, and then takes the
    labels and puts them into a separate vector `y`. The rest of the metadata is
    discarded unless the component needs it for some purpose, in which case this
    will be indicated by a parameter called something like `metadata`, which contains
    the list of columns in the DataFrame which contain the rest of metadata.</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="PandasConverter.__init__" class="doc_header"><code>PandasConverter.__init__</code><a href="https://github.com/Jaume-JCI/block_types/blob/main/block_types/core/data_conversion.py#L174" class="source_link" style="float:right">[source]</a></h3><blockquote><p><code>PandasConverter.__init__</code>(<strong><code>transform_uses_labels</code></strong>=<em><code>False</code></em>, <strong><code>transformed_index</code></strong>=<em><code>None</code></em>, <strong><code>transformed_columns</code></strong>=<em><code>None</code></em>, <strong><code>separate_labels</code></strong>=<em><code>True</code></em>, <strong>**<code>kwargs</code></strong>)</p>
</blockquote>

<pre><code>Initialize attributes and fields.

Parameters
----------
transform_uses_labels : bool, optional
    If True, the `transform` method receives as input data `X` a DataFrame where
    one of the columns is `label`, containing the ground-truth labels. This allows
    the transform method to modify the number of observations,
    changing the number of rows in the data and in the labels.
    See `SamplingComponent` class in `block_types.core.component_types`.
    If False, the input data `X` only contains data consumed by , without
    ground-truth labels.
transformed_index : array-like or None, optional
    Used after transforming the data. If the result of the transformation is
    a numpy array, two things can happen: 1) if the number of rows of this array
    is the same as the number of rows of the input DataFrame, then we convert
    the array to a DataFrame with the same index as the original; 2) if the number
    of rows is not the same, the index used for the new DataFrame is
    `transformed_index` if provided, or 0..N-1 (where N=number of rows) if not
    provided.
transformed_columns : array-like or None, optional
    Used after transforming the data. If the result of the transformation is
    a numpy array, two things can happen: 1) if the number of columns of this array
    is the same as the number of columns of the input DataFrame, then we convert
    the array to a DataFrame with the same columns as the original; 2) if the number
    of columns is not the same, the columns used for the new DataFrame is
    `transformed_columns` if provided, or 0..D-1 (where D=number of columns) if not
    provided.
separate_labels : bool, optional
    Used before calling the fit method. If separate_labels=True (default value),
    the `fit` method receives the data and labels separately in `X` and `y`
    respectively. If separate_labels=False, the `fit` method receives both the
    data and the labels in the same input `X`, where the labels are in a
    column of `X` called `label` (TODO: make this configurable). This last
    option is used by the `Pipeline` class, and its rationale is provided in
    the description of that class.</code></pre>

</div>

</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="PandasConverter.convert_before_fitting" class="doc_header"><code>PandasConverter.convert_before_fitting</code><a href="https://github.com/Jaume-JCI/block_types/blob/main/block_types/core/data_conversion.py#L231" class="source_link" style="float:right">[source]</a></h3><blockquote><p><code>PandasConverter.convert_before_fitting</code>(<strong><code>X</code></strong>, <strong><code>y</code></strong>=<em><code>None</code></em>)</p>
</blockquote>

<pre><code>By default, convert DataFrame X to numpy arrays X and y

The most common use of this method is:
- When calling the fit method, the data is received
  as a DataFrame.
- This DataFrame contains not only the data to be
  used for fitting our model, but also the
  ground-truth labels. This method takes only
  the data needed for fitting the model, and puts it
  into a matrix `X`, and then takes the labels and puts
  them into a separate vector `y`.

Other possibilities are:
  - If the data and the labels are separated in `X` and `y`
  (i.e., X does not include labels), no action is performed.
  - If `self.separate_labels` is False, the data and the labels
  are not separated, in which case the data `X`
  passed to the fit method will contain both data and labels.
  - It also allows to receive numpy arrays instead of DataFrames,
  in which case the data format is preserved.</code></pre>

</div>

</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="PandasConverter.convert_after_fitting" class="doc_header"><code>PandasConverter.convert_after_fitting</code><a href="https://github.com/Jaume-JCI/block_types/blob/main/block_types/core/data_conversion.py#L268" class="source_link" style="float:right">[source]</a></h3><blockquote><p><code>PandasConverter.convert_after_fitting</code>(<strong><code>X</code></strong>)</p>
</blockquote>

<pre><code>Do nothing. Return same data received.</code></pre>

</div>

</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="PandasConverter.convert_before_transforming" class="doc_header"><code>PandasConverter.convert_before_transforming</code><a href="https://github.com/Jaume-JCI/block_types/blob/main/block_types/core/data_conversion.py#L272" class="source_link" style="float:right">[source]</a></h3><blockquote><p><code>PandasConverter.convert_before_transforming</code>(<strong><code>X</code></strong>, <strong><code>new_columns</code></strong>=<em><code>None</code></em>, <strong>**<code>kwargs</code></strong>)</p>
</blockquote>

<pre><code>By default, remove labels from incoming DataFrame.

This method allows to remove the labels from the incoming DataFrame,
and then put them back after performing the transformation.
This behaviour can change if we set `self.transform_needs_labels=True`.
In this case, the labels are kept in the matrix `X` so that they can be
used during the transformation. This is done in particular by one type of
component called `SamplingComponent`, defined in `core.component_types`.
This is useful for components that do some sort of under-sampling or
over-sampling, changing the number of observations. When this occurs,
the labels need to be adjusted accordingly, so that the `transform` method
modifies both the data and the labels, both of whom are contained in the output
matrix `X`.</code></pre>

</div>

</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="PandasConverter.convert_after_transforming" class="doc_header"><code>PandasConverter.convert_after_transforming</code><a href="https://github.com/Jaume-JCI/block_types/blob/main/block_types/core/data_conversion.py#L310" class="source_link" style="float:right">[source]</a></h3><blockquote><p><code>PandasConverter.convert_after_transforming</code>(<strong><code>result</code></strong>, <strong>**<code>kwargs</code></strong>)</p>
</blockquote>

<pre><code>Convert the result produced by `transform`to DataFrame format.

If the input to `transform` was in DataFrame format, the `result`
given by `transform` is converted to DataFrame if it is not
produced in this format. Furthermore, if the `label` column was
in the input to `transform` and it is not in the output given
by `transform`, it is appended to the result.</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="Window2Dto3Dconverter" class="doc_header"><code>class</code> <code>Window2Dto3Dconverter</code><a href="https://github.com/Jaume-JCI/block_types/blob/main/block_types/core/data_conversion.py#L355" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>Window2Dto3Dconverter</code>(<strong><code>sequence_length</code></strong>:<code>int</code>, <strong><code>data_converter</code></strong>:<a href="/core.data_conversion.html#DataConverter"><code>DataConverter</code></a>=<em><code>None</code></em>, <strong>**<code>kwargs</code></strong>) :: <a href="/core.data_conversion.html#DataConverter"><code>DataConverter</code></a></p>
</blockquote>

<pre><code>Convert sequence of windows from WindowGenerator's 2D format to 3D.

Given a 2D Dataframe of size N x (W*D), where N=number of windows,
D=number of variables (dimensions), and W=size of windows, converts this
to a numpy array of N x D x W. Note that the order of the elements is
transposed: for each window, the has first the elements of a window in
one dimension, then the elements in the second dimension, etc. This
is transposed in the output to have the second and third axis be D and W
respectively.</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="Window2Dto3Dconverter.__init__" class="doc_header"><code>Window2Dto3Dconverter.__init__</code><a href="https://github.com/Jaume-JCI/block_types/blob/main/block_types/core/data_conversion.py#L366" class="source_link" style="float:right">[source]</a></h3><blockquote><p><code>Window2Dto3Dconverter.__init__</code>(<strong><code>sequence_length</code></strong>:<code>int</code>, <strong><code>data_converter</code></strong>:<a href="/core.data_conversion.html#DataConverter"><code>DataConverter</code></a>=<em><code>None</code></em>, <strong>**<code>kwargs</code></strong>)</p>
</blockquote>

<pre><code>Initialize common attributes and fields.

Parameters
----------
sequence_length : int
    Size of each window.
data_converter : DataConverter, optional
    DataConverter that will transform the input data to a 2D DataFrame of
    size N x (D*W), if it is not already in this format. PandasConverter
    is used by default.</code></pre>

</div>

</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="Window2Dto3Dconverter.convert_before_fitting" class="doc_header"><code>Window2Dto3Dconverter.convert_before_fitting</code><a href="https://github.com/Jaume-JCI/block_types/blob/main/block_types/core/data_conversion.py#L385" class="source_link" style="float:right">[source]</a></h3><blockquote><p><code>Window2Dto3Dconverter.convert_before_fitting</code>(<strong><code>X</code></strong>, <strong><code>y</code></strong>=<em><code>None</code></em>)</p>
</blockquote>

<pre><code>Convert incoming data before running fit method.

Parameters
----------
X : data (N observations x D dimensions)
    data used for fitting model parameters
y : labels (N observations), optional
    One dimensional array with N groundtruth labels.

Returns
-------
X : data (N observations x D dimensions)
    data with transformed format but same content
y : labels (N observations)
    labels with transformed format but same content</code></pre>

</div>

</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="Window2Dto3Dconverter.convert_after_fitting" class="doc_header"><code>Window2Dto3Dconverter.convert_after_fitting</code><a href="https://github.com/Jaume-JCI/block_types/blob/main/block_types/core/data_conversion.py#L407" class="source_link" style="float:right">[source]</a></h3><blockquote><p><code>Window2Dto3Dconverter.convert_after_fitting</code>(<strong><code>X</code></strong>)</p>
</blockquote>

<pre><code>Convert data after running fit method.

Calling this method is only required when convert_before_fitting
changes X "in place", instead of changing a copy of X. This might
be more efficient sometimes, and we have convert_after_fitting to
revert the previous change.

Parameters
----------
X : data (N observations x D dimensions)
    data used for fitting model parameters

Returns
-------
X : data (N observations x D dimensions)
    data with transformed format but same content</code></pre>

</div>

</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="Window2Dto3Dconverter.convert_before_transforming" class="doc_header"><code>Window2Dto3Dconverter.convert_before_transforming</code><a href="https://github.com/Jaume-JCI/block_types/blob/main/block_types/core/data_conversion.py#L428" class="source_link" style="float:right">[source]</a></h3><blockquote><p><code>Window2Dto3Dconverter.convert_before_transforming</code>(<strong><code>X</code></strong>, <strong>**<code>kwargs</code></strong>)</p>
</blockquote>

<pre><code>Convert data before running transform method.

Parameters
----------
X : data (N observations x D dimensions)
    data used to be transformed

Returns
-------
X : data (N observations x D dimensions)
    data with transformed format but same content</code></pre>

</div>

</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="Window2Dto3Dconverter.convert_after_transforming" class="doc_header"><code>Window2Dto3Dconverter.convert_after_transforming</code><a href="https://github.com/Jaume-JCI/block_types/blob/main/block_types/core/data_conversion.py#L446" class="source_link" style="float:right">[source]</a></h3><blockquote><p><code>Window2Dto3Dconverter.convert_after_transforming</code>(<strong><code>result</code></strong>, <strong>**<code>kwargs</code></strong>)</p>
</blockquote>

<pre><code>Convert result obtained after by transform method.

Parameters
----------
result : data (N' observations x D' dimensions)
        result obtained by transformed method

Returns
-------
result : data (N' observations x D' dimensions)
    result with transformed format but same content</code></pre>

</div>

</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="Window2Dto3Dconverter.transform" class="doc_header"><code>Window2Dto3Dconverter.transform</code><a href="https://github.com/Jaume-JCI/block_types/blob/main/block_types/core/data_conversion.py#L464" class="source_link" style="float:right">[source]</a></h3><blockquote><p><code>Window2Dto3Dconverter.transform</code>(<strong><code>df</code></strong>)</p>
</blockquote>

<pre><code>Convert input DataFrame `df` to numpy array in 3D format.

Given a 2D Dataframe of size N x (W*D), where N=number of windows,
D=number of variables (dimensions), and W=size of windows, converts this
to a numpy array of N x D x W. Note that the order of the elements is
transposed: for each window, the has first the elements of a window in
one dimension, then the elements in the second dimension, etc. This
is transposed in the output to have the second and third axis be D and W
respectively.</code></pre>

</div>

</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="Window2Dto3Dconverter.inverse_transform" class="doc_header"><code>Window2Dto3Dconverter.inverse_transform</code><a href="https://github.com/Jaume-JCI/block_types/blob/main/block_types/core/data_conversion.py#L480" class="source_link" style="float:right">[source]</a></h3><blockquote><p><code>Window2Dto3Dconverter.inverse_transform</code>(<strong><code>data</code></strong>)</p>
</blockquote>

<pre><code>Convert 3D numpy array `data` to 2D DataFrame.

Given a 3D numpy array of size N x D x W, convert this to Dataframe
of size N x (W*D), where N=number of windows, D=number of variables
(dimensions), and W=size of windows. Note that the order of the
elements is transposed: for each window, the output provides first
the elements of the first variable across the time-steps of the window,
then the elements of the second variable, etc.</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

</div>
 

