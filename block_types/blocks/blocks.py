# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/blocks/blocks.ipynb (unless otherwise specified).

__all__ = ['Splitter', 'SkSplitGenerator', 'PandasEvaluator']

# Cell
import sklearn
import numpy as np

from ..core.block_types import Component
from ..config import bt_defaults as dflt

# Cell
class Splitter (Component):
    def __init__ (self, training='train', validation='validation', test='test',
                  split_col='split', **kwargs):
        super().__init__ (**kwargs)

    def _apply (self, df):
        result = dict(training=df[df[self.split_col]==self.training],
                        validation=df[df[self.split_col]==self.validation],
                        test=df[df[self.split_col]==self.test])
        return {k:result[k] for k in result if not result[k].empty}

# Cell
class SkSplitGenerator (Component):
    def __init__ (self, split_generator, group_column=None, label_column=None, split_column=None,
                  use_splitter=False, **kwargs):
        super ().__init__ (**kwargs)
        self.splitter = Splitter () if use_splitter else None
        self.generator = None

    def _fit_apply (self, X, y=None, **kwargs):
        if y is None:
            if self.label_column is not None:
                y = X[self.label_column]
            else:
                raise ValueError ('either label_column must be set or y is passed')
        groups = X[self.group_column] if self.group_column is not None else None
        if self.generator is None: self.generator = self.split_generator.split (X, y, groups, **kwargs)
        train, test = next (self.generator)
        X = self._create_split (X, train, test)
        return X
    def _apply (self, X, **kwargs):
        train, test = np.array([]), np.arange (X.shape[0])
        X = self._create_split (X, train, test)
        return X

    def _create_split (self, X, train, test):
        if self.split_column is not None:
            X[self.split_column] = None
            X[self.split_column].iloc[train] = 'training'
            X[self.split_column].iloc[test] = 'test'
        else:
            X = (X, (train, test))
        if self.use_splitter:
            X = self.splitter (X)
        return X

# Cell
class PandasEvaluator (Component):
    def __init__ (self, classification_metrics='accuracy_score', regression_metrics=[], custom_metrics=[],
                  groundtruth_col='label', prediction_col='pred', classification_col='classification', **kwargs):
        classification_metrics = self._get_metrics (classification_metrics)
        regression_metrics = self._get_metrics (regression_metrics)
        super().__init__ (**kwargs)

    def _get_metrics (self, metrics):
        metrics = [metrics] if isinstance (metrics, str) else metrics
        for i, metric in enumerate(metrics):
            metrics[i] = getattr(sklearn.metrics, metrics[i]) if isinstance(metrics[i], str) else metrics[i]
        return metrics
    def _apply (self, df, **kwargs):
        dict_results = {metric.__name__: metric (df[self.groundtruth_col], df[self.classification_col])
                        for metric in self.classification_metrics}
        dict_results.update( {metric.__name__: metric (df[self.groundtruth_col], df[self.prediction_col])
                                for metric in self.regression_metrics})
        for metric in self.custom_metrics:
            dict_results.update (metric (df, label_col=self.groundtruth_col, prediction_col=self.prediction_col,
                                         classification_col=self.classification_col))
        return dict_results