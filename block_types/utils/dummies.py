# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/utils/dummies.ipynb (unless otherwise specified).

__all__ = ['Sum1', 'Multiply10', 'NewParallel', 'make_pipe1', 'make_pipe2', 'MinMaxClass', 'Min10', 'Max10',
           'make_pipe_fit1', 'make_pipe_fit2', 'Min10direct', 'Max10direct', 'Multiply10direct', 'DummyEstimator']

# Cell
import pandas as pd
import numpy as np
from sklearn.utils import Bunch

from ..core.block_types import (Component,
                                          PandasComponent,
                                          SamplingComponent,
                                          NoSaverComponent)
from ..core.compose import Sequential, Parallel
import block_types.config.bt_defaults as dflt

# Cell
class Sum1 (Component):
    def __init__ (self, raise_error=False, **kwargs):
        super().__init__ (**kwargs)
        self.applied = False
    def _apply (self, X):
        return X+1
    def apply (self, *X, **kwargs):
        self.applied = True
        if self.raise_error: raise RuntimeError (f'{self.name}: apply should not be called')
        return super().apply (*X, **kwargs)
    __call__ = apply
    transform = apply

class Multiply10 (Component):
    def __init__ (self, raise_error=False, **kwargs):
        super().__init__ (**kwargs)
        self.applied = False
    def _apply (self, X):
        return X*10
    def apply (self, *X, **kwargs):
        self.applied = True
        if self.raise_error: raise RuntimeError (f'{self.name}: apply should not be called')
        return super().apply (*X, **kwargs)
    __call__ = apply
    transform = apply

class NewParallel (Parallel):
    def __init__ (self, *components, raise_error=False, **kwargs):
        super().__init__ (*components, **kwargs)
        self.applied = False
    def apply (self, *X, **kwargs):
        self.applied = True
        if self.raise_error: raise RuntimeError (f'{self.name}: apply should not be called')
        return super().apply (*X, **kwargs)
    __call__ = apply
    transform = apply

def make_pipe1 (**kwargs):
    pipe = Sequential (Sum1 (name='A', **kwargs),
                        Multiply10 (name='B', **kwargs),
                        Sum1 (name='C', **kwargs),
                        Multiply10 (name='D', **kwargs),
                        Sum1 (name='E', **kwargs),
                        **kwargs)

    return pipe

def make_pipe2 (new_parallel=False, **kwargs):
    ParallelClass = Parallel if not new_parallel else NewParallel
    parallel = ParallelClass (
        Multiply10 (name='B1', **kwargs),
        Sequential (Multiply10 (name='B2a', **kwargs), Sum1 (name='B2b', **kwargs),
                    Multiply10 (name='B2c', **kwargs), **kwargs),
        Sequential (Sum1 (name='B3a', **kwargs), Multiply10 (name='B3b', **kwargs),
                    Sum1 (name='B3c', **kwargs), **kwargs),
        Sum1 (name='B4', **kwargs),
        initialize_result=lambda:np.array([]),
        join_result=lambda Xr, Xi_r, components, i: np.r_[Xr.reshape(-1,Xi_r.shape[1]), Xi_r],
        **kwargs)
    print (f'parallel class: {parallel.__class__}')
    pipe = Sequential (Sum1 (name='A', **kwargs), parallel, Sum1 (name='C', **kwargs),
                       Sum1 (name='D', **kwargs), **kwargs)
    pipe.gather_descendants ()

    return pipe



# Cell
class MinMaxClass (Component):
    def __init__ (self, raise_error=False, **kwargs):
        super().__init__ (**kwargs)
        self.estimator = Bunch()
        self.applied = False
        self.fitted = False
        self.fit_applied = False
    def apply (self, *X, **kwargs):
        self.applied = True
        if self.raise_error: raise RuntimeError (f'{self.name}: apply should not be called')
        return super().apply (*X, **kwargs)
    __call__ = apply
    transform = apply
    def fit (self, X, y=None, **kwargs):
        self.fitted = True
        if self.raise_error: raise RuntimeError (f'{self.name}: fit should not be called')
        return super().fit (X, y=y, **kwargs)
    def fit_apply (self, X, y=None, **kwargs):
        self.fit_applied = True
        if self.raise_error: raise RuntimeError (f'{self.name}: fit_apply should not be called')
        return super().fit_apply (X, y=y, **kwargs)
    fit_transform = fit_apply
    fit_predict = fit_apply

class Min10 (MinMaxClass):
    def __init__ (self, **kwargs):
        super().__init__ (**kwargs)
    def _fit (self, X, y=None):
        self.estimator['minim'] = X.min(axis=0)
    def _apply (self, X):
        return X*10+self.estimator.minim

class Max10 (MinMaxClass):
    def __init__ (self, **kwargs):
        super().__init__ (**kwargs)
    def _fit (self, X, y=None):
        self.estimator['maxim'] = X.max(axis=0)
    def _apply (self, X):
        return X*10+self.estimator.maxim

def make_pipe_fit1 (**kwargs):
    pipe = Sequential (Sum1 (name='A', **kwargs),
                       Min10 (name='B', **kwargs),
                        Max10 (name='C', **kwargs),
                        Sum1 (name='D', **kwargs),
                        Max10 (name='E', **kwargs),
                        Sum1 (name='F', **kwargs),
                        Min10 (name='G', **kwargs),
                        **kwargs)

    return pipe

def make_pipe_fit2 (new_parallel=False, **kwargs):
    ParallelClass = Parallel if not new_parallel else NewParallel
    parallel = ParallelClass (
        Multiply10 (name='B1', **kwargs),
        Min10 (name='B2', **kwargs),
        Sequential (Min10 (name='B3a', **kwargs), Max10 (name='B3b', **kwargs),
                    Sum1 (name='B3c', **kwargs), Min10 (name='B3d', **kwargs), **kwargs),
        Sequential (Sum1 (name='B4a', **kwargs), Max10 (name='B4b', **kwargs),
                    Min10 (name='B4c', **kwargs), Sum1 (name='B4d', **kwargs),
                    Max10 (name='B4e', **kwargs), **kwargs),
        Max10 (name='B5', **kwargs),
        initialize_result=lambda:np.array([]),
        join_result=lambda Xr, Xi_r, components, i: np.r_[Xr.reshape(-1,Xi_r.shape[1]), Xi_r],
        **kwargs)
    print (f'parallel class: {parallel.__class__}')
    pipe = Sequential (Sum1 (name='A0', **kwargs), Min10 (name='A1', **kwargs), parallel,
                       Sum1 (name='C', **kwargs), Max10 (name='D', **kwargs),
                       Sum1 (name='E', **kwargs), **kwargs)
    pipe.gather_descendants ()

    return pipe

# Cell
class Min10direct (Component):
    def __init__ (self, **kwargs):
        super().__init__ (**kwargs)
        self.create_estimator ()
    def _fit (self, X, y=None):
        self.estimator['minim'] = X.min(axis=0)
    def _apply (self, X):
        return X*10+self.estimator.minim

class Max10direct (Component):
    def __init__ (self, **kwargs):
        super().__init__ (**kwargs)
        self.create_estimator ()
    def _fit (self, X, y=None):
        self.estimator['maxim'] = X.max(axis=0)
    def _apply (self, X):
        return X*10+self.estimator.maxim

class Multiply10direct (Component):
    def __init__ (self, **kwargs):
        super().__init__ (**kwargs)
    def _apply (self, X):
        return X*10

# Cell
class DummyEstimator ():
    def __init__ (self, factor=3):
        self.factor = factor
    def fit (self, X, y=None):
        self.sum = sum(X)
    def transform (self, X):
        return X * self.factor + self.sum